/**
 * The LaunchDarkly JavaScript client interfaces - Electron SDK version.
 *
 * Documentation: http://docs.launchdarkly.com/docs/js-sdk-reference
 */
declare module 'ldclient-electron' {
  export * from 'ldclient-js-common';

  import {
    LDEvaluationDetail,
    LDEvaluationReason,
    LDFlagSet,
    LDFlagValue,
    LDClientBase,
    LDOptionsBase,
    LDUser
  } from 'ldclient-js-common';

  /**
   * Creates an instance of the LaunchDarkly Electron client to be used in the main process.
   */
  export const initializeInMain: (envKey: string, user: LDUser, options?: LDOptions) => LDElectronMainClient;

  /**
   * Creates an instance of the LaunchDarkly Electron client to be used in a renderer process, which
   * will receive all of its state from a client in the main process.
   */
  export const initializeInRenderer: (envKey?: string, options?: LDOptions) => LDElectronRendererClient;

  /**
   * Initialization options for the LaunchDarkly Electron SDK.
   */
  export interface LDOptions extends LDOptionsBase {
  }

  /**
   * The LaunchDarkly client's instance interface.
   *
   * @see http://docs.launchdarkly.com/docs/js-sdk-reference
   */
  export interface LDElectronMainClient extends LDClientBase {
    /**
     * Builds an object that encapsulates the state of all feature flags for the current user,
     * including the flag values and also metadata that can be used on the front end. This
     * method does not send analytics events back to LaunchDarkly.
     *
     * The most common use case for this method is to bootstrap a set of client-side
     * feature flags from a back-end service. Call the toJSON() method of the returned object
     * to convert it to the data structure used by the client-side SDK.
     *
     * Note that in an Electron application, it is normally unnecessary to use this method to
     * pass flags to a client in a renderer process. Instead, the standard way to do this is to
     * use initializeInRenderer() to create a client that automatically synchronizes itself with
     * the main process client. However, this method is still provided for compatibility in case
     * you are adapting code that used this mechanism with one of the server-side SDKs.
     * 
     * @returns the state object
     */
    allFlagsState: () => LDFlagsState;
  }

  /**
   * The LaunchDarkly client's instance interface.
   *
   * @see http://docs.launchdarkly.com/docs/js-sdk-reference
   */
  export interface LDElectronRendererClient extends LDClientBase {
  }

  /**
   * An object that contains the state of all feature flags, generated by the client's
   * allFlagsState() method.
   */
  export interface LDFlagsState {
    /**
     * True if this object contains a valid snapshot of feature flag state, or false if the
     * state could not be computed (for instance, because the client was offline or there
     * was no user).
     */
    valid: boolean;

    /**
     * Returns the value of an individual feature flag at the time the state was recorded.
     * It will be null if the flag returned the default value, or if there was no such flag.
     * @param key the flag key
     */
    getFlagValue: (key: string) => LDFlagValue;

    /**
     * Returns the evaluation reason for a feature flag at the time the state was recorded.
     * It will be null if reasons were not recorded, or if there was no such flag.
     * @param key the flag key
     */
    getFlagReason: (key: string) => LDEvaluationReason;
    
    /**
     * Returns a map of feature flag keys to values. If a flag would have evaluated to the
     * default value, its value will be null.
     *
     * Do not use this method if you are passing data to the front end to "bootstrap" the
     * JavaScript client. Instead, use toJSON().
     */
    allValues: () => LDFlagSet;

    /**
     * Returns a Javascript representation of the entire state map, in the format used by
     * the Javascript browser SDK. Use this method if you are passing data to the front end in
     * order to "bootstrap" the JavaScript client.
     *
     * Do not rely on the exact shape of this data, as it may change in future to support
     * the needs of the JavaScript client.
     */
    toJSON: () => object;
  }

  /**
   * Wraps an instance of the LaunchDarkly Electron main-process client with an alternate interface
   * that is the same as the LaunchDarkly Node SDK. This is intended to make it easier to port
   * LaunchDarkly-enabled Node.js code to Electron.
   */
  export const createNodeSdkAdapter: (client: LDElectronMainClient) => LDElectronNodeAdapterClient;

  /**
   * Interface for the Node SDK compatibility wrapper returned by createNodeSdkAdapter().
   *
   * Keep in mind that the underlying implementation is still the client-side SDK, which has a
   * single-current-user model. Therefore, when you call variation(flagKey, user, defaultValue),
   * it is really calling identify(user) first, obtaining flag values for that user, and then
   * evaluating the flag. This will perform poorly if you attempt to evaluate flags for a variety
   * of different users in rapid succession.
   */
  export interface LDElectronNodeAdapterClient {
    /**
     * @returns Whether the client library has completed initialization.
     */
    initialized: () => boolean;

    /**
     * Returns a Promise that will be resolved if and when the client is successfully initialized.
     * If initialization fails, the Promise will not resolve, but will not be rejected either
     * (unlike waitForInitialization).
     *
     * This method is deprecated and will be removed in a future release. Instead, use
     * waitForInitialization(), which waits for either success or failure.
     *
     * @returns a Promise containing the initialization state of the client
     */
    waitUntilReady: () => Promise<void>;

    /**
     * Returns a Promise that will be resolved if the client successfully initializes, or
     * rejected if client initialization has irrevocably failed (for instance, if it detects
     * that the SDK key is invalid). The success and failure cases can also be detected by listening
     * for the events "ready" and "failed".
     * @returns a Promise containing the initialization state of the client; if successful, the resolved
     * value is the same client object
     */
    waitForInitialization: () => Promise<LDElectronNodeAdapterClient>;

    /**
     * Retrieves a flag's value.
     *
     * @param key
     *   The key of the flag for which to retrieve the corresponding value.
     * @param user
     *   The user for the variation.
     *
     *   The variation call will automatically create a user in LaunchDarkly if a user with that user key doesn't exist already.
     *
     * @param defaultValue
     *   The value to use if the flag is not available (for example, if the
     *   user is offline or a flag is requested that does not exist).
     *
     * @param callback
     *   The callback to receive the variation result.
     *
     * @returns a Promise containing the flag value
     */
    variation: (
      key: string,
      user: LDUser,
      defaultValue: LDFlagValue,
      callback?: (err: any, res: LDFlagValue) => void
    ) => Promise<LDFlagValue>;

    /**
     * Retrieves a flag's value, along with information about how it was calculated, in the form
     * of an LDEvaluationDetail object.
     *
     * The reason property of the result will also be included in analytics events, if you are
     * capturing detailed event data for this flag.
     *
     * @param key
     *   The key of the flag for which to retrieve the corresponding value.
     * @param user
     *   The user for the variation.
     *
     *   The variation call will automatically create a user in LaunchDarkly if a user with that user key doesn't exist already.
     *
     * @param defaultValue
     *   The value to use if the flag is not available (for example, if the
     *   user is offline or a flag is requested that does not exist).
     *
     * @param callback
     *   The callback to receive the result.
     *
     * @returns a Promise containing the flag value and explanation
     */
    variationDetail: (
      key: string,
      user: LDUser,
      defaultValue: LDFlagValue,
      callback?: (err: any, res: LDEvaluationDetail) => void
    ) => Promise<LDEvaluationDetail>;

    /**
     * Retrieves the set of all flag values for a user.
     *
     * This method is deprecated; use allFlagsState() instead. Current versions of the client-side
     * SDK will not generate analytics events correctly if you pass the result of allFlags().
     *
     * @param user
     * @param callback
     *   The node style callback to receive the variation result.
     * @returns a Promise containing the set of all flag values for a user
     */
    allFlags: (
      user: LDUser,
      callback?: (err: any, res: LDFlagSet) => void
    ) => Promise<LDFlagSet>;

    /**
     * Builds an object that encapsulates the state of all feature flags for a given user,
     * including the flag values and also metadata that can be used on the front end. This
     * method does not send analytics events back to LaunchDarkly.
     *
     * The most common use case for this method is to bootstrap a set of client-side
     * feature flags from a back-end service. Call the toJSON() method of the returned object
     * to convert it to the data structure used by the client-side SDK.
     *
     * @param user The end user requesting the feature flags.
     * @param options Ignored - no options are supported for this method in Electron.
     * @param callback The node-style callback to receive the state result.
     * @returns a Promise containing the state object
     */
    allFlagsState: (
      user: LDUser,
      options?: object,
      callback?: (err: any, res: LDFlagsState) => void
    ) => Promise<LDFlagsState>;

    /**
     * In the Node SDK, secureModeHash computes an HMAC signature of a user signed with the
     * client's SDK key. This is not possible in Electron because the SDK key is not available,
     * so secureModeHash will always return an empty string.
     *
     * @param user
     *
     * @returns An empty string
     */
    secureModeHash: (user: LDUser) => string;

    /**
     * Closes all connections and resources used by the client.
     */
    close: () => void;

    /**
     *
     * @returns Whether the client is configured in offline mode.
     */
    isOffline: () => boolean;

    /**
     * Track page events to use in goals or A/B tests.
     *
     * LaunchDarkly automatically tracks pageviews and clicks that are
     * specified in the Goals section of their dashboard. This can be used
     * to track custom goals or other events that do not currently have
     * goals.
     *
     * @param key
     *   The event to record.
     * @param user
     *   The user to track.
     * @param data
     *   Additional information to associate with the event.
     */
    track: (key: string, user: LDUser, data?: any) => void;

    /**
     * Identifies a user to LaunchDarkly.
     *
     * This only needs to be called if the user changes identities because
     * normally the user's identity is set during client initialization.
     *
     * @param user
     *   A map of user options. Must contain at least the `key` property
     *   which identifies the user.
     */
    identify: (user: LDUser) => void;

    /**
     * Flush the queue
     *
     * Internally, the LaunchDarkly SDK keeps an event queue for track and identify calls.
     * These are flushed periodically (see configuration option: flushInterval)
     * and when the queue size limit (see configuration option: capacity) is reached.
     *
     * @param callback
     *    A function which will be called when the flush completes; if omitted, you
     *    will receive a Promise instead
     *
     * @returns a Promise which resolves once flushing is finished, if you did not
     * provide a callback; note that it will be rejected if the HTTP request fails, so be
     * sure to provide a rejection handler if you are not using a callback
     */
    flush: (callback?: (err: any, res: boolean) => void) => Promise<void>;
  }
}
